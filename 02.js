//실패율
// 실패율은 다음과 같이 정의한다.
// 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
// 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

// var n = 5; //총스테이지
// var stages = [2, 1, 2, 6, 2, 4, 3, 3]; //사용자 8명이 현재 머무르고 있는 스테이지
//result = [3,4,2,1,5]

//접근방법 : 배열의 길이는 사용자수, 각 스테이지를 배열화 한 후에 각 배열을 비교하여 총스테이지 배열에 값을줌. 그걸 내림차순으로 다시 정렬

//실패율은 어떻게 구할것인가?
//stage 1의 실패율 : 1/8, 즉 1 / 총 인덱스 수
//stage 2의 실패율 : 3/7, 즉 2의 값을 가진 요소 수 / 총인덱스에서 1을 뺀 수
//stage 3의 실패율 : 2/4, 즉 3의 값을 가진 요소 수 /총 인덱스에서 1,2을 뺀 수
//...

// function solution(n, stages) {
//   var answer = [];
//   var totalStage = []; //[1,2,3,4,5]
//   for (var i = 1; i <= n; i++) { //[2,1,2,6,2,4,3,3]
//     totalStage.push(i);
//   }

//   var fail = [];
//   for(let i =0; i<stages.length; i++){
//    if(stages[i] == 1){
//     stages[i] /
//    }
//   }

//   return answer;
// }
// console.log(solution(n, stages));

//다른 접근 방법
//filter 함수를 이용하니 간략하고 이해도 훨씬 쉬워졌다!!
//스테이지에 도달한 사람수와 머무르는 사람(클리어 하지 못한 사람)을 각각 변수로 지정해 그 수를 뽑아주고 나눈 수를 배열로..

var n = 5; //총스테이지
var stages = [2, 1, 2, 6, 2, 4, 3, 3];
function solution(n, stages) {
  answer = [];
  for (let i = 1; i <= n; i++) {
    const reach = stages.filter((x) => x >= i).length; //length를 붙여주어 길이로 반환 시킨다. 즉 i=1일때 해당 값은 1,2,2,2,3,4,4,6 이므로 배열의 길이인 8을 반환한다.
    //도달한 토탈 사람, i=1 1,2,2,2,3,4,4,6, i=2 2,2,2,3,3,4,6, i=3 3,3,4,6, i=4 4,6, i=5 6,
    let curr = stages.filter((x) => x === i).length;
    //현재 머무르는 사람, i=1 1, i=2 2,2,2, i=3 3,3, i=4 4, i=5작동안함, i=6 6
    //i=요소로 넣어라, 즉 stages 배열의 길이와 같은 new 배열을 만들어라.
    answer.push([i, curr / reach]); //이렇게 스테이지값에 따른 실패율이 나온다.
  }
  answer.sort((a, b) => b[1] - a[1]); //우리는 배열중 실패율 값, 즉 인덱스의 두번째 값을 비교해야되기 때문에
  return answer.map((x) => x[0]); // 그리고 표시는 스테이지 번호만,
  //즉 요소(x)의 첫번째 값만
}
console.log(solution(n, stages));
